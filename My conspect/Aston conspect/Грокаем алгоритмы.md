### §5. Хеш-таблицы
Их преимущество в том, что они работают почти мгновенно. Однако в хеш-функция должна соответствовать некоторым требованиям:
- Она должна быть последовательной. Допустим, вы передали ей строку "апельсины" и получили 4. Это значит, что каждый раз в будущем, передавая ей строку "апельсины", вы будете получать 4. Без этого хеш-таблица бесполезна.
- Разным словам должны соответствовать разные числа. Например, хеш-функция, которая возвращает 1 для каждого полученного слова, никуда не годится. В идеале каждое входное слово должно отображаться на свое число.
Такое решение работает, потому что:
- Хеш-функция неизменно связывает название с одним индексом. Каждый раз, когда она вызывается для строки "авокадо", вы получаете обратно одно и то же число. При первом вызове этой функции вы узнаете, где следует сохранить цену авокадо, а при последующих вызовах она сообщает, где взять эту цену.
- Хеш-функция связывает разные строки с разными индексами. "Авокадо" связывается с индексом 4, а "молоко" - с индексом 0. Для каждой строки находится отдельная позиция массива, в которой сохраняется цена этого товара.
- Хеш-функция знает размер массива и возвращает только действительные индексы. Таким образом, если длина массива равна 5 элементам, хеш-функция не вернет 100, потому что это значение не является действительным индексом в массиве.
Связывая воедино хеш-функцию и массив, мы получаем структуру данных, которая называется __хеш-таблицей__.

Хеш-таблицы отлично работают, когда вы хотите:
- создать связь, отображающую один объект на другой;
- найти значение в списке.

Хеши хорошо подходят для решения следующих задач:
- моделирование отношений между объектами;
- устранение дубликатов;
- кэширование/запоминание данных вместо выполнения работа на сервере.

###### Коллизии
Коллизии это явление/процесс, когда элементы пытаются записаться в одну и ту же ячейку памяти. Для решения этой проблемы существует множество решений. Простейшее из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.
Важные уроки:
- _выбор хеш-функций действительно важен_. Хеш-функция, отображающая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу;
- если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется. Но они не станут слишком длинными _при использовании хорошей хещ-функции_!

В среднем хеш-таблицы выполняют любые операции за время О(1). Время О(1) называется _постоянным_.
Для предотвращения коллизий необходимы:
- низкий коэффициент заполнения;
- хорошая хеш-функция.

__Коэффициент заполнения__
Коэффициент заполнения хеш-таблицы вычисляется по простой формуле.
$$\frac{Кол-во \ эл. \ в \ хещ-таблице}{Общее \ кол-во \ элементов}$$
Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7.

- Хеш-таблица создается объединением хеш-функции с массивом.
- Коллизии нежелательны. Хеш-функция должна свести количество колu лизии к минимуму.
- Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.
- Хеш-таблицы хорошо подходят для моделирования отношений между объектами. 
- Как только коэффициент заполнения превышает 0,7, пора изменять раз­ мер хеш-таблицы.
- Хеш-таблицы используются для кэширования данных (например, на веб-серверах). 
- Хеш-таблицы хорошо подходят для обнаружения дубликатов.

### §6. Поиск в ширину.
###### Алгоритм поиска в ширину
Алгоритм помогает ответить на вопросы:
- тип 1: существует ли путь от узла А к узлу В?
- тип 2: как выглядит кратчайший путь от узла А к узлу В?

Существуют связи первого уровня, связи второго уровня и т.д. Алгоритм поиска в ширину помогает нам найти не только кратчайший путь, но и есть ли он вообще. Однако при проверке нам нужно её делать по уровням и не допустить ошибку. Для операций такого рода существует специальная структура данных, которая называется _очередью_.

###### Очереди
Очередь работает точно также, как и в реальной жизни. Поддерживаются всего две операции: постановка в очередь и извлечение из очереди. Если вы поставите в очередь два элемента, то элемент, добавленный пер­вым, будет извлечен из очереди раньше второго. Очередь относится к категории структур данных FIFO: First In, First Out ("первым вошел, первым вышел"). А стек принадлежит к числу структур данных LIFO: Last In, First Out ("последним пришел, первым вышел").

###### Реализация графа
Хочется отметить, что существуют направленные графы и ненаправленные, также графы состоят из узлов и ребер (На картинке представлен пример) (Например, оба следующих графа эквиваленты): <br>
![[Pasted image 20240410234919.png]]

__Реализация алгоритма__
Далее представлена реализация на Python, но после можно ознакомиться с реализацией на Java.
Все начинается с создания очереди. В Python для создания _двусторонней очереди (дека)_ используется функция deque:
```Python
from collections import deque
search_queue = deque()
search_queue += graph["you"]
```

Стоит дать пояснение, что graph\["you"\] это некий словарь (хеш-таблица).
Теперь рассмотрим остальное:
```Python
while search_queue:
	person = search_queue.popleft()
	if person_is_seller(person):
		print(person + " is a mango seller!")
	else:
		search_queue += graph[person]
return False
```

Ну и напоследок нужно определить функцию person_is_seller, которая сообщает, является ли человек продавцом манго. Например, функция может выглядеть так:
```Python
def person_is_seller(name):
	return name[-1] == 'm'
```

Алгоритм продолжает работать до тех пор, пока: 
- не будет найден продавец манго,
или 
- очередь не опустеет (в этом случае продавца манго нет).

Ну и чтобы не получилось зацикливания, нужно создать очередь, в которой будут уже проверенные узлы, дабы не выполнять дополнительную работу. Вот окончательный результат поиска в ширину на Python:
```Python
def search(name):
	search_queue = deque()
	search_queue += graph[name]
	searched = []
	while search_queue:
		person = search_queue.popleft()
		if not person in searched:
			print(person + " is a mango seller!")
			return True
		else:
			search_queue += graph[person]
			searched.append(person)
	return False

search("you")
```

Вот аналогичная реализация на Java:
```Java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Queue;

public class BFS {
    public static HashMap<String, String[]> graph = new HashMap<>();

    public static boolean search(String name) {

        Queue<String> searchQueue = new ArrayDeque<>();

        searchQueue.addAll(java.util.Arrays.asList(graph.get(name)));

        ArrayList<String> searched = new ArrayList<>();

        while (!searchQueue.isEmpty()) {
            String person = searchQueue.poll();
            if (!searched.contains(person)) {
                if (personIsSeller(person)) {
                    System.out.println(person + " is a mango seller!");

                    return true;
                } else {
                    searchQueue.addAll(java.util.Arrays.asList(graph.get(person)));
                    searched.add(person);
                }
            }
        }

        return false;

    }

    public static boolean personIsSeller(String name) {

        return name.charAt(name.length() - 1) == 'm';

    }

    public static void main(String[] args) {

        graph.put("you", new String[]{"alice", "bob", "claire"});
        graph.put("bob", new String[]{"anuj", "peggy"});
        graph.put("alice", new String[]{"peggy"});
        graph.put("claire", new String[]{"thom", "jonny"});
        graph.put("anuj", new String[]{});
        graph.put("peggy", new String[]{});
        graph.put("thom", new String[]{});
        graph.put("jonny", new String[]{});

        search("you");

    }

}
```

###### Время выполнения
Если мы выполняем поиск по всей сети, значит, мы прошли по каждому ребру. Таким образом, время выполнения составляет как минимум О(_количество ребер_).

Также не стоит забывать, что мы храним очередь поиска. Добавление одного человека в очередь выполняется за постоянное время: О(1). Выполнение операции для каждого человека потребует суммарного времени О(_количество людей_). Поиск в ширину выполняется за время О(_количество людей + количество ребер_), что обычно записывается в форме О(V + E) (V - количество вершин, E - количество ребер).

### §7. Алгоритм Дейкстры.
Алгоритм поиска в ширину находит путь с минимальным количеством сегментов. Если нам нужно найти самый быстрый путь (с меньшим суммарным весом), то быстрее всего это делается при помощи другого алгоритма, который называется _алгоритмом Дейкстры_.

###### Работа с алгоритмом Дейкстры
Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
2. Обновить стоимости соседей этого узла.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

При работе с алгоритмом Дейкстры, с каждым ребром графа связывается число, называемое _весом_.
![[Pasted image 20240411230927.png]]<br>
Граф с весами называется _взвешенным графом_. Граф без весов называется _невзвешенным графом_.
![[Pasted image 20240411231021.png]]<br>
> [!tip] Правила работы алгоритма
> Алгоритм Дейкстры работает только с _направленными ациклическими графами_, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).

>[!tip] Ключевая идея алгоритма
>Ключевая идея алгоритма Дейкстры заключается в следующем: _в графе ищется путь с наименьшей стоимостью. Пути к этому узлу с меньшими затратами не существует!_

Хочется отметить, что алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Следовательно, _использование алгоритма Дейкстры с графом, содержащим ребра с отрицательным весом, невозможно_. Если мы хотим найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_. 

###### Реализация
В качестве примера будем использовать следующий граф:
![[Pasted image 20240411234028.png]] <br>
Для реализации понадобятся три хеш-таблицы:
![[Pasted image 20240411234059.png]]<br>
Конечный код выглядит так (на Python):
```Python
def find_lowest_cost_node(costs):
	lowest_cost = float("inf")
	lowest_cost_node = None
	for node in costs:
		cost = costs[node]
		if cost < lowest_cost and node not in processed:
			lowest_cost = cost
			lowest_cost_node = node
	return lowest_cost_node

node = find_lowest_cost_node(costs)
while node is not None:
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():
		new_cost = cost + neighbors[n]
		if costs[n] > new_cost:
			costs[n] = new_cost
			parents[n] = node
	processed.append(node)
	node = find_lowest_cost_node(costs)
```

### §8. Жадные алгоритмы.

В книге приводятся примеры составления оптимального расписания, где мы можем посетить максимальное количество уроков. А также про вора с рюкзаком у которого есть вместительность и нам нужно унести как можно дороже предметы. Вот на втором примере жадные алгоритмы как раз показывают не идеальное, а хорошее, оптимальное решение поставленной задачи, отсюда мы можем сделать вывод: иногда идеальное - враг хорошего. 

Стоит также сказать, что понимается под "жадными алгоритмами". В технической терминологии: на каждом шаге выбирается _локально-оптимальное решение_, а в итоге вы получаете глобально-оптимальное решение. Ну и как теперь видно по определению и примерам, жадные работают не всегда. Но они просты в реализации!

В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. И в таких областях жадные алгоритмы работают просто отлично, потому что они просто реализуются, а полученое решение обычно близко к оптимуму.

Ну и после некоторого введения. Мы можем перейти к довольно существенным задачам, одной из которых является покрытие множества. И тут у нас есть один из самых очевидных последовательностей действий:
1. Составить список всех возможных подмножеств станций - так называемое _степенное множество_. В нем содержаться 2^n возможных подмножеств.
2. Из этого списка выбирается множество с наименьшим набором станций, покрывающих все 50 штатов.

Проблема в том, что вычисление всех возможных подмножеств станций займет слишком много времени. Для n станций потребуется времени O(2^n). Для малого количества станций такое решение допустимо, однако при даже большем 10, к примеру 32 это уже займет 13.6 лет.

Поэтому мы можем прийти к выводу, что не существует алгоритма, который будет вычислять подмножества с приемлемой скоростью!

Ну и тут мы приходим к приближенным алгоритмам.

###### Приближенные алгоритмы
На помощь приходят жадные алгоритмы! Вот как выглядит жадный алго­ ритм, который выдает результат, достаточно близкий к оптимуму: 
1. Выбрать станцию, покрывающую наибольшее количество штатов, еще не входящих в покрытие. Если станция будет покрывать некоторые штаты, уже входящие в покрытие, это нормально. 
2. Повторять, пока остаются штаты, не входящие в покрытие.

А теперь поговорим о NP-полных задачах.

###### NP-полные задачи.

> [!note] Определение
> __NP-полная задача__ - в теории алгоритмов задача с ответом "да" или "нет" из класса NP, к которой можно свести любую другую задачи из этого класса за полиноминальное время. В каком-то смысле задача с подмножеством "типовых" задач в классе NP.

> [!info] Класс NP
> В теории алгоритмов __классом NP__ называеют множество задач разрешимости, решение которых возможно проверить на машине Тьюринга за время, не превосходящее значение некоторого многочлена от размера входных данных, при наличии некоторых дополнительных сведений.

Проще говоря, наша задача о коммивояжере и задача, где мы должны выбрать минимальное количество радиовышек для нашей радиостанции - NP-полные задачи.

__Приближенное решение__
Мы можем составить приближенное решение для задачи о коммивояжере. Приблизительный алгоритм будет таков: начальный город выбирается произвольно, после чего каждый раз, когда коммивояжер выбирает следующий город, он перемещается в ближайший город из тех, что он еще не посещал. Допустим он начинает в Марине. <br>
![[Pasted image 20240420184426.png]]<br>
Суммарное расстояние - 71 миля. Может это не самый короткий путь, но он достаточно близок к нему.

###### Признаки для NP-полной задачи

> [!tip] Несколько характерных признаков:
> - ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;
> - формулировка "все комбинации X" часто указывает на NP-полноту задачи;
> - вам приходится вычислять все возможные варианты X, потому что задачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NP-полной;
> - если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NP-полной;
> - если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения, она может оказаться NP-полной;
> - можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае ваша задача определенно является NP-полной.


### §9. Динамическое программирование.

> [!note] Определение
> __Динамическое программирование__ - способ решения сложных задач путём разбиения их на более простые задачи.

Мы будем рассмотривать решение на примере задачи о рюкзаке. Для начала мы для наглядности нарисуем табличку, которая будет представлять предметы в виде строк, а столбцы - емкость рюкзака от 1 до 4 фунтов. <br>
![[Pasted image 20240420185453.png]]<br>
Для начала заполним первую строку, где мы запишем стоимость нашего предмета и проверим постетится ли он в рюкзак. После заполнения мы получим следующую картину: <br>
![[Pasted image 20240420185714.png]]<br>
_Эта строка представляет текущую лучшую оценку максимума._ Пока что максимальная стоимость предметов с емкостью 4 фунта составляет $1500.

