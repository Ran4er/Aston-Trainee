### §5. Хеш-таблицы
Их преимущество в том, что они работают почти мгновенно. Однако в хеш-функция должна соответствовать некоторым требованиям:
- Она должна быть последовательной. Допустим, вы передали ей строку "апельсины" и получили 4. Это значит, что каждый раз в будущем, передавая ей строку "апельсины", вы будете получать 4. Без этого хеш-таблица бесполезна.
- Разным словам должны соответствовать разные числа. Например, хеш-функция, которая возвращает 1 для каждого полученного слова, никуда не годится. В идеале каждое входное слово должно отображаться на свое число.
Такое решение работает, потому что:
- Хеш-функция неизменно связывает название с одним индексом. Каждый раз, когда она вызывается для строки "авокадо", вы получаете обратно одно и то же число. При первом вызове этой функции вы узнаете, где следует сохранить цену авокадо, а при последующих вызовах она сообщает, где взять эту цену.
- Хеш-функция связывает разные строки с разными индексами. "Авокадо" связывается с индексом 4, а "молоко" - с индексом 0. Для каждой строки находится отдельная позиция массива, в которой сохраняется цена этого товара.
- Хеш-функция знает размер массива и возвращает только действительные индексы. Таким образом, если длина массива равна 5 элементам, хеш-функция не вернет 100, потому что это значение не является действительным индексом в массиве.
Связывая воедино хеш-функцию и массив, мы получаем структуру данных, которая называется __хеш-таблицей__.

Хеш-таблицы отлично работают, когда вы хотите:
- создать связь, отображающую один объект на другой;
- найти значение в списке.

Хеши хорошо подходят для решения следующих задач:
- моделирование отношений между объектами;
- устранение дубликатов;
- кэширование/запоминание данных вместо выполнения работа на сервере.

__Коллизии__
Коллизии это явление/процесс, когда элементы пытаются записаться в одну и ту же ячейку памяти. Для решения этой проблемы существует множество решений. Простейшее из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.
Важные уроки:
- _выбор хеш-функций действительно важен_. Хеш-функция, отображающая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу;
- если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется. Но они не станут слишком длинными _при использовании хорошей хещ-функции_!

В среднем хеш-таблицы выполняют любые операции за время О(1). Время О(1) называется _постоянным_.
Для предотвращения коллизий необходимы:
- низкий коэффициент заполнения;
- хорошая хеш-функция.

__Коэффициент заполнения__
Коэффициент заполнения хеш-таблицы вычисляется по простой формуле.
$$\frac{Кол-во \ эл. \ в \ хещ-таблице}{Общее \ кол-во \ элементов}$$
Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7.

- Хеш-таблица создается объединением хеш-функции с массивом.
- Коллизии нежелательны. Хеш-функция должна свести количество колu лизии к минимуму.
- Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.
- Хеш-таблицы хорошо подходят для моделирования отношений между объектами. 
- Как только коэффициент заполнения превышает 0,7, пора изменять раз­ мер хеш-таблицы.
- Хеш-таблицы используются для кэширования данных (например, на веб-серверах). 
- Хеш-таблицы хорошо подходят для обнаружения дубликатов.

### §6. Поиск в ширину.
