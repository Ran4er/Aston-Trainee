### §5. Хеш-таблицы
Их преимущество в том, что они работают почти мгновенно. Однако в хеш-функция должна соответствовать некоторым требованиям:
- Она должна быть последовательной. Допустим, вы передали ей строку "апельсины" и получили 4. Это значит, что каждый раз в будущем, передавая ей строку "апельсины", вы будете получать 4. Без этого хеш-таблица бесполезна.
- Разным словам должны соответствовать разные числа. Например, хеш-функция, которая возвращает 1 для каждого полученного слова, никуда не годится. В идеале каждое входное слово должно отображаться на свое число.
Такое решение работает, потому что:
- Хеш-функция неизменно связывает название с одним индексом. Каждый раз, когда она вызывается для строки "авокадо", вы получаете обратно одно и то же число. При первом вызове этой функции вы узнаете, где следует сохранить цену авокадо, а при последующих вызовах она сообщает, где взять эту цену.
- Хеш-функция связывает разные строки с разными индексами. "Авокадо" связывается с индексом 4, а "молоко" - с индексом 0. Для каждой строки находится отдельная позиция массива, в которой сохраняется цена этого товара.
- Хеш-функция знает размер массива и возвращает только действительные индексы. Таким образом, если длина массива равна 5 элементам, хеш-функция не вернет 100, потому что это значение не является действительным индексом в массиве.
Связывая воедино хеш-функцию и массив, мы получаем структуру данных, которая называется __хеш-таблицей__.

Хеш-таблицы отлично работают, когда вы хотите:
- создать связь, отображающую один объект на другой;
- найти значение в списке.

Хеши хорошо подходят для решения следующих задач:
- моделирование отношений между объектами;
- устранение дубликатов;
- кэширование/запоминание данных вместо выполнения работа на сервере.

###### Коллизии
Коллизии это явление/процесс, когда элементы пытаются записаться в одну и ту же ячейку памяти. Для решения этой проблемы существует множество решений. Простейшее из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.
Важные уроки:
- _выбор хеш-функций действительно важен_. Хеш-функция, отображающая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу;
- если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется. Но они не станут слишком длинными _при использовании хорошей хещ-функции_!

В среднем хеш-таблицы выполняют любые операции за время О(1). Время О(1) называется _постоянным_.
Для предотвращения коллизий необходимы:
- низкий коэффициент заполнения;
- хорошая хеш-функция.

__Коэффициент заполнения__
Коэффициент заполнения хеш-таблицы вычисляется по простой формуле.
$$\frac{Кол-во \ эл. \ в \ хещ-таблице}{Общее \ кол-во \ элементов}$$
Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7.

- Хеш-таблица создается объединением хеш-функции с массивом.
- Коллизии нежелательны. Хеш-функция должна свести количество колu лизии к минимуму.
- Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.
- Хеш-таблицы хорошо подходят для моделирования отношений между объектами. 
- Как только коэффициент заполнения превышает 0,7, пора изменять раз­ мер хеш-таблицы.
- Хеш-таблицы используются для кэширования данных (например, на веб-серверах). 
- Хеш-таблицы хорошо подходят для обнаружения дубликатов.

### §6. Поиск в ширину.
###### Алгоритм поиска в ширину
Алгоритм помогает ответить на вопросы:
- тип 1: существует ли путь от узла А к узлу В?
- тип 2: как выглядит кратчайший путь от узла А к узлу В?

Существуют связи первого уровня, связи второго уровня и т.д. Алгоритм поиска в ширину помогает нам найти не только кратчайший путь, но и есть ли он вообще. Однако при проверке нам нужно её делать по уровням и не допустить ошибку. Для операций такого рода существует специальная структура данных, которая называется _очередью_.

###### Очереди
Очередь работает точно также, как и в реальной жизни. Поддерживаются всего две операции: постановка в очередь и извлечение из очереди. Если вы поставите в очередь два элемента, то элемент, добавленный пер­вым, будет извлечен из очереди раньше второго. Очередь относится к категории структур данных FIFO: First In, First Out ("первым вошел, первым вышел"). А стек принадлежит к числу структур данных LIFO: Last In, First Out ("последним пришел, первым вышел").

###### Реализация графа
Хочется отметить, что существуют направленные графы и ненаправленные, также графы состоят из узлов и ребер (На картинке представлен пример) (Например, оба следующих графа эквиваленты): <br>
![[Pasted image 20240410234919.png]]

__Реализация алгоритма__
Далее представлена реализация на Python, но после можно ознакомиться с реализацией на Java.
Все начинается с создания очереди. В Python для создания _двусторонней очереди (дека)_ используется функция deque:
```Python
from collections import deque
search_queue = deque()
search_queue += graph["you"]
```

Стоит дать пояснение, что graph\["you"\] это некий словарь (хеш-таблица).
Теперь рассмотрим остальное:
```Python
while search_queue:
	person = search_queue.popleft()
	if person_is_seller(person):
		print(person + " is a mango seller!")
	else:
		search_queue += graph[person]
return False
```

Ну и напоследок нужно определить функцию person_is_seller, которая сообщает, является ли человек продавцом манго. Например, функция может выглядеть так:
```Python
def person_is_seller(name):
	return name[-1] == 'm'
```

Алгоритм продолжает работать до тех пор, пока: 
- не будет найден продавец манго,
или 
- очередь не опустеет (в этом случае продавца манго нет).

Ну и чтобы не получилось зацикливания, нужно создать очередь, в которой будут уже проверенные узлы, дабы не выполнять дополнительную работу. Вот окончательный результат поиска в ширину на Python:
```Python
def search(name):
	search_queue = deque()
	search_queue += graph[name]
	searched = []
	while search_queue:
		person = search_queue.popleft()
		if not person in searched:
			print(person + " is a mango seller!")
			return True
		else:
			search_queue += graph[person]
			searched.append(person)
	return False

search("you")
```

Вот аналогичная реализация на Java:
```Java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Queue;

public class BFS {
    public static HashMap<String, String[]> graph = new HashMap<>();

    public static boolean search(String name) {

        Queue<String> searchQueue = new ArrayDeque<>();

        searchQueue.addAll(java.util.Arrays.asList(graph.get(name)));

        ArrayList<String> searched = new ArrayList<>();

        while (!searchQueue.isEmpty()) {
            String person = searchQueue.poll();
            if (!searched.contains(person)) {
                if (personIsSeller(person)) {
                    System.out.println(person + " is a mango seller!");

                    return true;
                } else {
                    searchQueue.addAll(java.util.Arrays.asList(graph.get(person)));
                    searched.add(person);
                }
            }
        }

        return false;

    }

    public static boolean personIsSeller(String name) {

        return name.charAt(name.length() - 1) == 'm';

    }

    public static void main(String[] args) {

        graph.put("you", new String[]{"alice", "bob", "claire"});
        graph.put("bob", new String[]{"anuj", "peggy"});
        graph.put("alice", new String[]{"peggy"});
        graph.put("claire", new String[]{"thom", "jonny"});
        graph.put("anuj", new String[]{});
        graph.put("peggy", new String[]{});
        graph.put("thom", new String[]{});
        graph.put("jonny", new String[]{});

        search("you");

    }

}
```

###### Время выполнения
Если мы выполняем поиск по всей сети, значит, мы прошли по каждому ребру. Таким образом, время выполнения составляет как минимум О(_количество ребер_).

Также не стоит забывать, что мы храним очередь поиска. Добавление одного человека в очередь выполняется за постоянное время: О(1). Выполнение операции для каждого человека потребует суммарного времени О(_количество людей_). Поиск в ширину выполняется за время О(_количество людей + количество ребер_), что обычно записывается в форме О(V + E) (V - количество вершин, E - количество ребер).

### §7. Алгоритм Дейкстры.
Алгоритм поиска в ширину находит путь с минимальным количеством сегментов. Если нам нужно найти самый быстрый путь (с меньшим суммарным весом), то быстрее всего это делается при помощи другого алгоритма, который называется _алгоритмом Дейкстры_.

###### Работа с алгоритмом Дейкстры
Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
2. Обновить стоимости соседей этого узла.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

При работе с алгоритмом Дейкстры, с каждым ребром графа связывается число, называемое _весом_.
![[Pasted image 20240411230927.png]]<br>
Граф с весами называется _взвешенным графом_. Граф без весов называется _невзвешенным графом_.
![[Pasted image 20240411231021.png]]<br>
> [!tip] Правила работы алгоритма
> Алгоритм Дейкстры работает только с _направленными ациклическими графами_, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).

>[!tip] Ключевая идея алгоритма
>Ключевая идея алгоритма Дейкстры заключается в следующем: _в графе ищется путь с наименьшей стоимостью. Пути к этому узлу с меньшими затратами не существует!_

Хочется отметить, что алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Следовательно, _использование алгоритма Дейкстры с графом, содержащим ребра с отрицательным весом, невозможно_. Если мы хотим найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_. 

###### Реализация
В качестве примера будем использовать следующий граф:
![[Pasted image 20240411234028.png]] <br>
Для реализации понадобятся три хеш-таблицы:
![[Pasted image 20240411234059.png]]<br>
Конечный код выглядит так (на Python):
```Python
def find_lowest_cost_node(costs):
	lowest_cost = float("inf")
	lowest_cost_node = None
	for node in costs:
		cost = costs[node]
		if cost < lowest_cost and node not in processed:
			lowest_cost = cost
			lowest_cost_node = node
	return lowest_cost_node

node = find_lowest_cost_node(costs)
while node is not None:
	cost = costs[node]
	neighbors = graph[node]
	for n in neighbors.keys():
		new_cost = cost + neighbors[n]
		if costs[n] > new_cost:
			costs[n] = new_cost
			parents[n] = node
	processed.append(node)
	node = find_lowest_cost_node(costs)
```

### §8. Жадные алгоритмы.
