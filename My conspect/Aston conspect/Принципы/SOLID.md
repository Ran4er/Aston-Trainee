**Single Responsibility Principle**
Формулировка: "Каждый объект должен иметь одну обязанность и эта обязанность должна полностью инкапсулированна в класс"

Через ваш класс должна проходить только одна ось изменений. Наш класс должен содержать поля и методы, относящиеся к одному вопросу

**Open Closed Principle**
Формулировка: "Принцип открытости и закрытости устанавливает следующее положение программные сущности (классы, модули, функции и т.п.), должны быть открыты для расширения, но закрыты для изменения."
Как соблюдать этот принцип, существует два способа:
1. Бертрана Мейера: Мы создаем класс и ничего в нем не меняем (кроме баг фиксов), расширение происходит за счет наследования. Интерфейс потомка может отличаться от предка (сомнительно).
2. Боба Мартина: Работать нужно в обратную сторону (полиморфность). Клиентский код должен зависеть от интерфейса, который неизменный. Новая реализация использует тот же самый интерфейс, возможно как-то делегируя вызывания из старого кода/наследника (старого кода).
Допустим у нас есть класс клиента и класс сервера, можно было бы настроить взаимодействие напрямую, клиента и сервера. ОДНАКО это нарушение принципа D. Поэтому мы должны вынести серверный интерфейс и создать зависимость клиентского кода от серверного интерфейса.

**The Liskov Substitution Principle**
Формулировка Боба Мартина: "Декларирует функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом"
Формулировка Барбары: "В том случае если Q(X) свойство верованное по отношению к объектам X некого типа T, то свойство Q(Y) также будет верным относительно ряда объектов Y которые относятся к типу S, при этом S тип некого типа T"

Более простыми словами можно сказать: поведение следующих классов не должно противоречить поведению заданным базовым классом.

Очень важный принцип, которому нужно следовать!

Принцип LSP писателями учебников по C++: "Подкласс не должен требовать от вызывающего кода больше чем базовый класс и не должен предоставлять вызывающему коду меньше, чем базовый класс"

(Пример с фигурами)

Частное нарушение - бросание исключений в неподдерживаемых методах. 

**The Interface Segregation**
Формулировка: "Много интерфейсов специально предназначенных для клиентов, лучше чем один интерфейс общего назначения"
В формулировке Боба Мартина: "Клиенты не должны зависеть от методов, которые они не используют. То есть если какой-то метод интерфейсов не используется клиентом, то изменение этого метода не должны приводить к необходимости внесения изменения в клиентский код"

Интерфейс является принадлежностью клиента и он содержит только те методы, которые нужны клиенту. Для каждого требуется свой интерфейс (разумеется если реализуют разные методы)

Пример: "Имеется Fasade, по которому мы делаем интерфейс и в последствии какие-то классы клиенты берут этот интерфейс, но для каждого требуются разные методы для реализации их потребностей, другие нам не интересны" - тут идет нарушение нашего принципа

Чем проще и реалистичнее интерфейс, тем ресурсоемкой является его реализация в новых классах и тем меньше причин его модификации.

**The Dependency Inversion Principle**
Важнейший принцип ООП, используемый для уменьшения зацепления компьютерных программ.
Формулировка №1: "Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций"
Формулировка №2: "Абстракция не должна зависеть от деталей. Детали должны зависеть от абстракций"

Мы должны использовать все свои классы через интерфейсы. Надо не бояться писать интерфейсы, однако нужно писать их так, чтобы не нужно было к ним часто обращаться за изменениями их кода. 